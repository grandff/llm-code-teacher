from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from models import ErrorResponse
from dotenv import load_dotenv
import uvicorn
import os
from routers import ollama_run, celery_status

from pprint import pprint
import shutil
import git


# .env 파일에서 환경 변수 로드
load_dotenv()

# fastapi
app = FastAPI()

# routers
app.include_router(ollama_run.router)
app.include_router(celery_status.router)

ALLOWED_DOMAINS = os.getenv("ALLOWED_DOMAINS", "").split(",")
REQUIRED_HEADERS = {"API-Key": os.getenv("API_KEY")}

@app.middleware("http")
async def check_header_middleware(request: Request, call_next):
    headers = request.headers

    # Verify domain
    # TODO 도메인 정해지면 그때 바꾸기 + json으로 리턴
    # if "host" not in headers or headers["host"] not in ALLOWED_DOMAINS:
            # error_response = ErrorResponse(detail="Invalid header")
            # return JSONResponse(status_code=403, content=error_response.dict())
    #     raise HTTPException(status_code=403, detail="Domain not allowed")

    # Verify headers    
    for key, value in REQUIRED_HEADERS.items():        
        if key not in headers or headers[key] != value:
            error_response = ErrorResponse(detail="Invalid header")
            return JSONResponse(status_code=403, content=error_response.dict())

    response = await call_next(request)
    return response


@app.middleware("https")
async def check_header_middleware(request: Request, call_next):
    headers = request.headers

    # Verify domain
    # TODO 도메인 정해지면 그때 바꾸기 + json으로 리턴
    # if "host" not in headers or headers["host"] not in ALLOWED_DOMAINS:
    #     raise HTTPException(status_code=403, detail="Domain not allowed")

    # Verify headers
    for key, value in REQUIRED_HEADERS.items():
        if key not in headers or headers[key] != value:
            error_response = ErrorResponse(detail="Invalid header")
            return JSONResponse(status_code=403, content=error_response.dict())

    response = await call_next(request)
    return response

@app.get("/health")
async def health_check():
    return {"status": "ok"}

@app.post("/health")
async def health_check():
    return {"status": "ok"}

@app.get("/")
async def main_check(request: Request):
    return {"status": "ok"}


# 로컬 리포지토리 경로 설정
LOCAL_REPO_PATH = "/tmp/repo"
# 퍼스널 액세스 토큰 또는 SSH 키 사용 시 필요
ACCESS_TOKEN = "glpat-kBC-LCPdX27xw95j8TLk"

@app.post("/webhook")
async def webhook_post_check(request: Request):
    payload = await request.json()
    print(payload)
    
    # 필요한 정보를 추출
    project_info = payload['project']
    localhost_url_1= project_info['http_url']
    localhost_url_2= "http://nginx/gitlab/root/todo.git" #테스트 url 향후에는 수정해야함
    print("localhost_url_1:", localhost_url_1)
    print("localhost_url_1:", localhost_url_2)
    repo_url = localhost_url_2.replace("http://", f"http://oauth2:{ACCESS_TOKEN}@")
    
    commit_sha = payload['checkout_sha']
    commits = payload['commits']
    
    modified_files_content = {}

    # 로컬 디렉토리 정리
    if os.path.exists(LOCAL_REPO_PATH):
        shutil.rmtree(LOCAL_REPO_PATH)

    try :
        # 리포지토리 클론
        repo = git.Repo.clone_from(repo_url, LOCAL_REPO_PATH)

        # 특정 커밋으로 체크아웃
        repo.git.checkout(commit_sha)

        # 수정된 파일 목록 가져오기 및 파일 내용 읽기
        for commit in commits:
            for file_path in commit["modified"]:
                absolute_file_path = os.path.join(LOCAL_REPO_PATH, file_path)

                # 파일 디렉토리가 존재하는지 확인하고 파일 내용 읽기
                if os.path.exists(absolute_file_path):
                    with open(absolute_file_path, 'r') as file:
                        modified_files_content[file_path] = file.read()
                else:
                    modified_files_content[file_path] = "File does not exist."        
    except Exception as e:
        print(e)
        return {"status" : "no", "error": str(e)}
    return {"status": "ok webhook"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
    
# uvicorn app.main:app --host 0.0.0.0 --port 8000